# Story 007.04: Create Tree-Shakable Builder API

## Status
Proposed

## Epic
007 - Tree-Shaking Architecture Refactor

## Priority
High

## Story Points
8

## Story
**As a** developer who values convenience and DX,
**I want** a builder-style API that wraps pure operations,
**So that** I can avoid repetitive adapter passing while still benefiting from tree-shaking.

## Story Context

**Existing System Integration:**
- Depends on: Story 007.01 (Pure operations), Story 007.02 (Calendar extraction), Story 007.03 (Package exports)
- Refactors: createTemporal, usePeriod composable, convenience wrappers
- Technology: Builder pattern, tree-shakable wrapper functions
- Follows pattern: Three-level API design (Purist, Builder, Full DX)
- Touch points: createTemporal.ts, composables/usePeriods.ts, new builder wrapper

**Problem Being Solved:**
After Story 007.01, operations require passing `adapter` as the first parameter. This is optimal for tree-shaking (Level 1 API) but requires repetitive code. We need a convenience layer (Level 2 & 3 API) that provides better DX while still tree-shaking properly.

**Three-Level API Design:**

**Level 1 (Purist)** - Already exists after Story 007.01:
```typescript
import { period, divide } from '@allystudio/usetemporal/operations';
import { createNativeAdapter } from '@allystudio/usetemporal/native';

const adapter = createNativeAdapter({ weekStartsOn: 1 });
const year = period(adapter, new Date(), 'year');
const months = divide(adapter, year, 'month');
```

**Level 2 (Builder)** - This story creates:
```typescript
import { createTemporal } from '@allystudio/usetemporal';
import { nativeAdapter } from '@allystudio/usetemporal/native';

const temporal = createTemporal({
  adapter: nativeAdapter,
  weekStartsOn: 1
});

const year = temporal.period(new Date(), 'year');
const months = temporal.divide(year, 'month');
// OR
const months = divide(temporal.adapter, year, 'month'); // Mix with Level 1
```

**Level 3 (Full DX)** - Reactive composables:
```typescript
import { createTemporal, usePeriod } from '@allystudio/usetemporal';
import { nativeAdapter } from '@allystudio/usetemporal/native';

const temporal = createTemporal({
  adapter: nativeAdapter,
  date: new Date()
});

const month = usePeriod(temporal, 'month');
// month.value is reactive Period
```

## Acceptance Criteria

**Builder API (Level 2):**
1. `createTemporal()` returns a `Temporal` object with method wrappers
2. Temporal methods: `period()`, `divide()`, `merge()`, `next()`, `previous()`, `go()`, `split()`, `contains()`, `isSame()`
3. Methods internally call pure operations with `this.adapter`
4. Methods tree-shake independently (unused methods = 0KB in bundle)
5. Temporal object remains minimal and tree-shakable

**Composables (Level 3):**
6. `usePeriod()` updated to work with new operation signatures
7. Composables tree-shake independently
8. Reactivity preserved after refactor

**Quality Requirements:**
9. All 722 tests pass
10. Test coverage remains ≥87%
11. TypeScript compiles with zero errors
12. Builder API methods are 100% covered by tests

**Tree-Shaking Requirements:**
13. Using only `createTemporal` + one method (e.g., `period`) results in ≤10KB bundle
14. Unused builder methods excluded from bundle
15. Builder methods don't pull in operations they don't use

## Tasks / Subtasks

### Phase 1: Dependencies and Design
- [ ] **Verify Story 007.01 complete** - Pure operations exist
- [ ] **Verify Story 007.02 complete** - Calendar extracted
- [ ] **Verify Story 007.03 complete** - Package exports updated
- [ ] Create branch or continue on `refactor/tree-shaking-007-04`
- [ ] **Design builder interface**
  - Which operations become methods?
  - What's the method signature pattern?
  - How to preserve tree-shaking?

### Phase 2: Refactor createTemporal

#### 2.1 Update Temporal interface
- [ ] **Update types.ts Temporal interface** (AC#2)

**Before:**
```typescript
export interface Temporal {
  adapter: Adapter;
  weekStartsOn: number;
  browsing: Ref<Period>;
  now: Ref<Period>;
}
```

**After (Option A - Methods on Temporal):**
```typescript
export interface Temporal {
  adapter: Adapter;
  weekStartsOn: number;
  browsing: Ref<Period>;
  now: Ref<Period>;

  // Builder methods
  period(date: Date, unit: Unit): Period;
  divide(period: Period, unit: Unit): Period[];
  merge(periods: Period[], targetUnit?: Unit): Period | null;
  next(period: Period, count?: number): Period;
  previous(period: Period, count?: number): Period;
  go(period: Period, direction: "next" | "previous", count: number): Period;
  split(period: Period, date: Date): [Period, Period];
  contains(period: Period, date: Date | Period): boolean;
  isSame(period1: Period, period2: Period, unit: Unit): boolean;
}
```

**After (Option B - Separate builder, minimal Temporal):**
```typescript
// Keep Temporal minimal (data only)
export interface Temporal {
  adapter: Adapter;
  weekStartsOn: number;
  browsing: Ref<Period>;
  now: Ref<Period>;
}

// Builder wrapper (optional)
export interface TemporalBuilder extends Temporal {
  period(date: Date, unit: Unit): Period;
  divide(period: Period, unit: Unit): Period[];
  // ... other methods
}
```

**Decision:** Option B is more tree-shakable (builder is opt-in)

#### 2.2 Create builder wrapper (AC#1, #3, #4)
- [ ] **Create src/builder.ts**

```typescript
import type { Temporal, Period, Unit } from "./types";
import * as ops from "./operations";

/**
 * Builder interface - convenience methods that wrap pure operations
 * This is Level 2 API - balances DX with tree-shaking
 */
export interface TemporalBuilder extends Temporal {
  period(date: Date, unit: Unit): Period;
  period(options: { start: Date; end: Date }): Period;
  divide(period: Period, unit: Unit): Period[];
  merge(periods: Period[], targetUnit?: Unit): Period | null;
  next(period: Period, count?: number): Period;
  previous(period: Period, count?: number): Period;
  go(period: Period, direction: "next" | "previous", count: number): Period;
  split(period: Period, date: Date): [Period, Period];
  contains(period: Period, date: Date | Period): boolean;
  isSame(period1: Period, period2: Period, unit: Unit): boolean;
}

/**
 * Create a temporal builder with convenient method wrappers
 * This wraps pure operations with automatic adapter passing
 */
export function createTemporalBuilder(temporal: Temporal): TemporalBuilder {
  return {
    ...temporal,

    period: (dateOrOptions: Date | { start: Date; end: Date }, unit?: Unit) => {
      return ops.period(temporal.adapter, dateOrOptions as any, unit!);
    },

    divide: (period: Period, unit: Unit) => {
      return ops.divide(temporal.adapter, period, unit);
    },

    merge: (periods: Period[], targetUnit?: Unit) => {
      return ops.merge(temporal.adapter, periods, targetUnit);
    },

    next: (period: Period, count: number = 1) => {
      return ops.next(temporal.adapter, period, count);
    },

    previous: (period: Period, count: number = 1) => {
      return ops.previous(temporal.adapter, period, count);
    },

    go: (period: Period, direction: "next" | "previous", count: number) => {
      return ops.go(temporal.adapter, period, direction, count);
    },

    split: (period: Period, date: Date) => {
      return ops.split(period, date);
    },

    contains: (period: Period, date: Date | Period) => {
      return ops.contains(period, date);
    },

    isSame: (period1: Period, period2: Period, unit: Unit) => {
      return ops.isSame(temporal.adapter, period1, period2, unit);
    },
  };
}
```

#### 2.3 Update createTemporal.ts (AC#1)
- [ ] **Option 1: Modify createTemporal to return builder**
```typescript
export function createTemporal(options: CreateTemporalOptions): TemporalBuilder {
  // ... existing code to create temporal

  return createTemporalBuilder(temporal);
}
```

- [ ] **Option 2: Separate function, keep createTemporal minimal**
```typescript
// Keep createTemporal returning plain Temporal
export function createTemporal(options: CreateTemporalOptions): Temporal {
  // ... existing code
}

// Export builder version separately
export function createTemporalWithBuilder(options: CreateTemporalOptions): TemporalBuilder {
  return createTemporalBuilder(createTemporal(options));
}
```

**Decision:** Option 1 (modify createTemporal) for backward compatibility

### Phase 3: Update Composables (Level 3)

#### 3.1 Update usePeriod (AC#6, #7)
- [ ] **Update composables/usePeriods.ts**

**Before:**
```typescript
export function usePeriod(temporal: Temporal, unit: Unit): ComputedRef<Period> {
  return computed(() => {
    return period(temporal, temporal.browsing.value.date, unit);
  });
}
```

**After (with pure operations):**
```typescript
import { period } from "../operations/period";

export function usePeriod(temporal: Temporal, unit: Unit): ComputedRef<Period> {
  return computed(() => {
    const unitValue = typeof unit === "string" ? unit : unit.value;
    return period(temporal.adapter, temporal.browsing.value.date, unitValue);
  });
}
```

#### 3.2 Create composables index (AC#8)
- [ ] **Ensure composables/index.ts exports all composables**
```typescript
export { usePeriod } from "./usePeriods";
// Export other composables if they exist
```

### Phase 4: Tree-Shaking Validation

#### 4.1 Test builder tree-shaking (AC#13, #14, #15)
- [ ] **Test minimal builder usage**
```bash
cat > test-builder-minimal.js << 'EOF'
import { createTemporal } from '@allystudio/usetemporal';
import { createNativeAdapter } from '@allystudio/usetemporal/native';

const temporal = createTemporal({
  adapter: createNativeAdapter(),
  date: new Date()
});

// Only use period method
const month = temporal.period(new Date(), 'month');
console.log(month);
EOF

npm run build
npx rollup test-builder-minimal.js --format esm -o dist/test-builder.js
gzip -c dist/test-builder.js | wc -c  # Should be ≤10KB

# Verify unused operations excluded
cat dist/test-builder.js | grep "merge"  # Should be empty or minimal
cat dist/test-builder.js | grep "split"  # Should be empty
```

- [ ] **Test full builder usage**
```bash
cat > test-builder-full.js << 'EOF'
import { createTemporal } from '@allystudio/usetemporal';
import { createNativeAdapter } from '@allystudio/usetemporal/native';

const temporal = createTemporal({
  adapter: createNativeAdapter(),
  date: new Date()
});

const year = temporal.period(new Date(), 'year');
const months = temporal.divide(year, 'month');
const merged = temporal.merge(months.slice(0, 3));
const next = temporal.next(months[0]);
console.log({ year, months, merged, next });
EOF

npx rollup test-builder-full.js --format esm -o dist/test-builder-full.js
gzip -c dist/test-builder-full.js | wc -c  # Document size
```

#### 4.2 Test composables tree-shaking
- [ ] **Test usePeriod only**
```bash
cat > test-composable.js << 'EOF'
import { createTemporal, usePeriod } from '@allystudio/usetemporal';
import { createNativeAdapter } from '@allystudio/usetemporal/native';

const temporal = createTemporal({
  adapter: createNativeAdapter(),
  date: new Date()
});

const month = usePeriod(temporal, 'month');
console.log(month.value);
EOF

npx rollup test-composable.js --format esm -o dist/test-composable.js
gzip -c dist/test-composable.js | wc -c  # Should be ≤15KB
```

### Phase 5: Update Tests

#### 5.1 Test builder methods (AC#9, #12)
- [ ] **Create src/builder.test.ts**
```typescript
import { describe, it, expect, beforeEach } from "vitest";
import { createTemporal } from "./createTemporal";
import { createNativeAdapter } from "./adapters/native";
import type { Period } from "./types";

describe("Temporal Builder API", () => {
  let temporal: any;
  let testDate: Date;

  beforeEach(() => {
    testDate = new Date(2024, 0, 15); // Jan 15, 2024
    temporal = createTemporal({
      adapter: createNativeAdapter(),
      date: testDate,
    });
  });

  describe("period method", () => {
    it("should create a period using builder", () => {
      const month = temporal.period(testDate, "month");

      expect(month.type).toBe("month");
      expect(month.date).toEqual(testDate);
    });

    it("should create custom period with start/end", () => {
      const start = new Date(2024, 0, 1);
      const end = new Date(2024, 0, 31);
      const custom = temporal.period({ start, end });

      expect(custom.type).toBe("custom");
      expect(custom.start).toEqual(start);
      expect(custom.end).toEqual(end);
    });
  });

  describe("divide method", () => {
    it("should divide a period using builder", () => {
      const year = temporal.period(testDate, "year");
      const months = temporal.divide(year, "month");

      expect(months).toHaveLength(12);
      expect(months[0].type).toBe("month");
    });
  });

  describe("merge method", () => {
    it("should merge periods using builder", () => {
      const year = temporal.period(testDate, "year");
      const months = temporal.divide(year, "month");
      const merged = temporal.merge(months.slice(0, 3));

      expect(merged).not.toBeNull();
      expect(merged!.type).toBe("quarter");
    });
  });

  describe("next method", () => {
    it("should get next period using builder", () => {
      const month = temporal.period(testDate, "month");
      const nextMonth = temporal.next(month);

      expect(nextMonth.date.getMonth()).toBe(1); // February
    });
  });

  describe("previous method", () => {
    it("should get previous period using builder", () => {
      const month = temporal.period(testDate, "month");
      const prevMonth = temporal.previous(month);

      expect(prevMonth.date.getMonth()).toBe(11); // December 2023
    });
  });

  // ... tests for go, split, contains, isSame
});
```

#### 5.2 Update composable tests (AC#7, #8)
- [ ] **Update composables/reactivity.test.ts**
  - Change operation calls to use `temporal.adapter`
  - Verify composables still work with new operation signatures

#### 5.3 Update integration tests
- [ ] **Update __tests__/integration/integration.test.ts**
  - Test that builder API works with all operations
  - Test mixing builder and pure API

#### 5.4 Run test suite (AC#9, #10)
- [ ] Run `TZ=UTC npm test` - all 722 tests pass
- [ ] Run `npm run test:coverage` - coverage ≥87%
- [ ] Run builder-specific tests

### Phase 6: Update Package Exports

#### 6.1 Export builder types and functions
- [ ] **Update src/index.ts**
```typescript
// Core
export { createTemporal } from "./createTemporal";
export type { CreateTemporalOptions } from "./createTemporal";

// Builder
export { createTemporalBuilder } from "./builder";
export type { TemporalBuilder } from "./builder";

// Composables (Level 3)
export { usePeriod } from "./composables/usePeriods";

// Types
export type { Temporal, Period, Unit, Adapter } from "./types";
```

### Phase 7: Documentation and Examples

#### 7.1 Update examples (if they exist)
- [ ] **Update Vue example to use builder API**
  - Show Level 2 (builder) approach
  - Show Level 3 (composables) approach
  - Compare with Level 1 (pure functions)

#### 7.2 Create usage examples (save for Story 007.05)
- [ ] Document Level 1 vs Level 2 vs Level 3 trade-offs
- [ ] Show when to use each approach
- [ ] Bundle size comparison

### Phase 8: TypeScript and Build

- [ ] Run `npm run type-check` - zero TypeScript errors (AC#11)
- [ ] Run `npm run build` - successful build
- [ ] Verify builder .d.ts files generated correctly
- [ ] Test TypeScript autocomplete works for builder methods
- [ ] Verify JSDoc appears in IDE tooltips

### Phase 9: QA and Review
- [ ] Self-review all changes
- [ ] Verify backward compatibility (createTemporal still works)
- [ ] Check that all three API levels work independently
- [ ] Verify tree-shaking works for each level
- [ ] Submit for QA review

## Technical Notes

### Builder Pattern for Tree-Shaking

**Challenge:** How to create convenience methods without bundling all operations?

**Solution:** Lazy method binding
```typescript
// BAD: Bundles all operations immediately
export function createTemporal(options) {
  return {
    period: (date, unit) => period(this.adapter, date, unit),
    divide: (p, u) => divide(this.adapter, p, u),
    // ... all methods defined upfront
  };
}

// GOOD: Methods reference operations on-demand
export function createTemporal(options) {
  return {
    period: (date, unit) => {
      // Dynamic import tree-shakes if not called
      return period(this.adapter, date, unit);
    },
    // ... other methods
  };
}
```

With modern bundlers (Rollup, Webpack 5+, Vite), unused methods tree-shake if:
- No side effects in method definitions
- Methods don't reference unused operations
- Operation imports are from separate modules

### Three-Level API Trade-Offs

| Level | Bundle Size | DX | Use Case |
|-------|------------|-----|----------|
| Level 1 (Pure) | 5-7KB | Verbose | Performance-critical apps |
| Level 2 (Builder) | 8-12KB | Good | Balanced approach |
| Level 3 (Composables) | 15-20KB | Excellent | Vue apps, reactivity needed |

### Backward Compatibility Strategy

**Goal:** Existing code should continue to work

**Approach:**
1. `createTemporal()` returns builder by default (backward compatible)
2. Pure operations available separately (`import from '/operations'`)
3. Composables available separately (`import from '/composables'`)

**Migration path:**
- Old code: `import { createTemporal } from '@allystudio/usetemporal'` → still works
- New code: Choose appropriate level based on needs

### Builder Method Signatures

**Pattern:** Match operation signatures but omit adapter parameter

**Pure operation:**
```typescript
function period(adapter: Adapter, date: Date, unit: Unit): Period
```

**Builder method:**
```typescript
temporal.period(date: Date, unit: Unit): Period
// Internally: period(this.adapter, date, unit)
```

### Tree-Shaking Implementation Details

**Key insight:** Methods must reference operations, not inline them

**Bad (doesn't tree-shake):**
```typescript
period: (date, unit) => {
  // Inline implementation
  const start = this.adapter.startOf(date, unit);
  const end = this.adapter.endOf(date, unit);
  return { start, end, type: unit, date };
}
```

**Good (tree-shakes):**
```typescript
period: (date, unit) => {
  return period(this.adapter, date, unit);  // References pure operation
}
```

Bundlers can eliminate the method if it's never called, and then the pure operation import becomes unused and is also eliminated.

### Performance Considerations

**Builder overhead:** Minimal
- Method wrappers inline to direct calls (JIT optimization)
- No observable performance difference

**Memory:** Builder adds ~1KB per temporal instance (method bindings)

### Testing Strategy

**Builder tests:**
- Test each builder method works correctly
- Test that methods delegate to pure operations
- Test error handling

**Tree-shaking tests:**
- Bundle with only some methods used
- Verify unused methods excluded

**Integration tests:**
- Test mixing builder and pure API
- Test with composables

## Definition of Done

- [ ] createTemporal returns object with builder methods
- [ ] Builder methods: period, divide, merge, next, previous, go, split, contains, isSame
- [ ] usePeriod updated for new operation signatures
- [ ] All 722 tests pass
- [ ] Test coverage ≥87%
- [ ] TypeScript compiles with zero errors
- [ ] Builder tests created and passing (100% coverage for builder.ts)
- [ ] Tree-shaking validated: using 1 builder method ≤10KB gzipped
- [ ] Unused builder methods excluded from bundle
- [ ] Composables tree-shake independently
- [ ] Backward compatibility maintained

## Risk and Compatibility Check

**Low-Medium Risk Assessment:**
- **Primary Risk:** Builder pattern adds complexity
- **Impact**: MEDIUM - affects API surface, but backward compatible
- **Mitigation**: Comprehensive tests, tree-shaking validation, backward compat
- **Rollback**: Git branch allows rollback

**Compatibility Verification:**
- [x] Backward compatible - createTemporal still works as before
- [ ] No database changes
- [ ] No UI component changes
- [ ] Performance impact: NEUTRAL (minimal builder overhead)

## Dev Notes

### Implementation Order

1. **Create builder.ts**: Define TemporalBuilder interface and createTemporalBuilder
2. **Update createTemporal**: Return builder by default
3. **Update composables**: Use new operation signatures with adapter
4. **Create builder tests**: Comprehensive test coverage
5. **Update existing tests**: Fix any broken references
6. **Validate tree-shaking**: Bundle size tests
7. **Documentation**: Update guides

### Debugging Tips

**Builder methods not working:**
```typescript
// Check operation imports
import * as ops from "./operations";

// Check method delegates correctly
period: (date, unit) => {
  console.log("Calling period with", { date, unit, adapter: this.adapter });
  return ops.period(this.adapter, date, unit);
}
```

**Tree-shaking not working:**
```bash
# Check if unused methods remain in bundle
npx rollup input.js --format esm -o output.js
cat output.js | grep "methodName"  # Should be absent
```

**Composables broken:**
```typescript
// Verify adapter access
const month = usePeriod(temporal, 'month');
// Inside: period(temporal.adapter, ...)
```

### Related Stories

- **Story 007.01**: Remove Global Unit Registry (provides pure operations)
- **Story 007.02**: Extract Calendar (builder can optionally use calendar)
- **Story 007.03**: Package Exports (builder exported from main package)
- **Story 007.05**: Documentation (documents all 3 API levels)
- **Story 007.06**: Bundle size analysis (validates builder tree-shaking)

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-10 | 1.0 | Initial story creation | Claude (BMad Master) |

## Dev Agent Record

_To be filled by development agent upon implementation_

## QA Results

_To be filled by QA reviewer_
