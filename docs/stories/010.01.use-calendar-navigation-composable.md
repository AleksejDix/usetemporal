# Story 010.01: Create useCalendarNavigation Composable

## Status
Draft

## Story
**As a** developer building the divide visualization,  
**I want** a headless composable that manages navigation state,  
**So that** I can control view transitions and breadcrumb history without UI coupling.

## Story Context

**Existing System Integration:**
- Integrates with: Vue 3 Composition API, @vue/reactivity
- Technology: TypeScript, Vue 3 composables
- Follows pattern: Headless composable pattern (logic without UI)
- Touch points: Will be used by all visualization view components

## Acceptance Criteria

**Functional Requirements:**
1. Composable tracks current view state ('year' | 'month' | 'day')
2. Maintains navigation history for breadcrumb trail
3. Provides methods to navigate to each view level
4. Supports both drill-down and drill-up navigation
5. Emits navigation events for animation coordination

**Integration Requirements:**
6. Works with Vue 3 reactivity system
7. Fully typed with TypeScript
8. No UI dependencies (headless)
9. Can be tested without component mounting

**Quality Requirements:**
10. Navigation state changes are atomic
11. History maintains proper parent-child relationships
12. Memory efficient (limits history depth)
13. Provides computed properties for current path

## Technical Notes

- **Integration Approach:** Pure composition function with reactive state
- **Existing Pattern Reference:** Similar to Vue Router's navigation guards but simpler
- **Key Constraints:** Must be SSR-safe (no direct DOM access)

## Definition of Done

- [ ] Composable created in `/vitepress/.vitepress/composables/useCalendarNavigation.ts`
- [ ] TypeScript interfaces defined for all state types
- [ ] Navigation state ref implemented
- [ ] History tracking array implemented
- [ ] Navigation methods (navigateToYear, navigateToMonth, navigateToDay)
- [ ] Back navigation method
- [ ] Breadcrumb path computed property
- [ ] Reset method for returning to initial state
- [ ] Unit tests with 100% coverage
- [ ] JSDoc documentation for all public methods
- [ ] Example usage in test file

## Risk and Compatibility Check

**Minimal Risk Assessment:**
- **Primary Risk:** State management complexity
- **Mitigation:** Keep state structure simple and flat
- **Rollback:** N/A - new code only

**Compatibility Verification:**
- [ ] No breaking changes (new code)
- [ ] No database changes
- [ ] No UI components in this story
- [ ] No performance concerns

## Dev Notes

### File Structure
```
/vitepress/.vitepress/composables/useCalendarNavigation.ts
/vitepress/.vitepress/composables/__tests__/useCalendarNavigation.test.ts
```

### Interface Design

```typescript
interface NavigationState {
  view: 'year' | 'month' | 'day'
  history: NavigationEntry[]
  maxHistorySize: number
}

interface NavigationEntry {
  view: 'year' | 'month' | 'day'
  label: string
  data?: any // For storing selected period info
}

interface UseCalendarNavigationReturn {
  // State
  currentView: Readonly<Ref<'year' | 'month' | 'day'>>
  navigationHistory: Readonly<Ref<NavigationEntry[]>>
  breadcrumbs: ComputedRef<NavigationEntry[]>
  canGoBack: ComputedRef<boolean>
  
  // Methods
  navigateToYear(label: string, data?: any): void
  navigateToMonth(label: string, data?: any): void
  navigateToDay(label: string, data?: any): void
  goBack(): void
  reset(): void
  
  // Events (optional, could use Vue's emitter)
  onNavigate?: (entry: NavigationEntry) => void
}
```

### Implementation Approach

```typescript
export function useCalendarNavigation(options?: {
  maxHistory?: number
  onNavigate?: (entry: NavigationEntry) => void
}): UseCalendarNavigationReturn {
  const state = reactive<NavigationState>({
    view: 'year',
    history: [{ view: 'year', label: 'Year View' }],
    maxHistorySize: options?.maxHistory ?? 10
  })
  
  const currentView = readonly(toRef(state, 'view'))
  const navigationHistory = readonly(toRef(state, 'history'))
  
  const breadcrumbs = computed(() => {
    // Return current navigation path
    return state.history
  })
  
  const canGoBack = computed(() => state.history.length > 1)
  
  function navigate(view: 'year' | 'month' | 'day', label: string, data?: any) {
    const entry: NavigationEntry = { view, label, data }
    
    // Handle history
    if (view === 'year') {
      // Reset to root
      state.history = [entry]
    } else {
      // Add to history (with max size limit)
      state.history.push(entry)
      if (state.history.length > state.maxHistorySize) {
        state.history.shift()
      }
    }
    
    state.view = view
    options?.onNavigate?.(entry)
  }
  
  // ... implement other methods
  
  return {
    currentView,
    navigationHistory,
    breadcrumbs,
    canGoBack,
    navigateToYear: (label, data) => navigate('year', label, data),
    navigateToMonth: (label, data) => navigate('month', label, data),
    navigateToDay: (label, data) => navigate('day', label, data),
    goBack,
    reset
  }
}
```

### Testing Approach

Test cases should cover:
1. Initial state
2. Navigation to each view type
3. History tracking and limits
4. Back navigation
5. Reset functionality
6. Breadcrumb computation
7. Edge cases (empty history, max history)
8. Event emission

### Usage Example

```typescript
const {
  currentView,
  breadcrumbs,
  navigateToMonth,
  goBack
} = useCalendarNavigation({
  onNavigate: (entry) => console.log('Navigated to:', entry)
})

// Navigate to month
navigateToMonth('March 2024', { year: 2024, month: 3 })

// Check state
console.log(currentView.value) // 'month'
console.log(breadcrumbs.value) // [{ view: 'year', ... }, { view: 'month', ... }]

// Go back
goBack() // Returns to year view
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-07-27 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record
(To be populated by dev agent)

## QA Results
(To be populated by QA agent)