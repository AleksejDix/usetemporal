# Story 010.02: Create useCalendarData Composable

## Status
Draft

## Story
**As a** developer building the divide visualization,  
**I want** a headless composable that manages calendar data using divide operations,  
**So that** I can efficiently load and cache time period data without UI concerns.

## Story Context

**Existing System Integration:**
- Integrates with: useTemporal core library, divide operation
- Technology: TypeScript, Vue 3 composables, @vue/reactivity
- Follows pattern: Headless composable with data caching
- Touch points: useCalendarNavigation composable, Period types

## Acceptance Criteria

**Functional Requirements:**
1. Composable creates and manages a temporal instance
2. Provides computed periods for current year
3. Divides year into months using divide()
4. Divides selected month into days using divide()
5. Caches divide results to prevent recalculation
6. Handles period selection state

**Integration Requirements:**
7. Integrates with useCalendarNavigation for view state
8. Uses actual useTemporal divide() operations
9. Fully typed with Period interfaces
10. Works with temporal's reactive browsing state

**Quality Requirements:**
11. Divide operations are memoized/cached
12. Only computes visible data (lazy loading)
13. Clears unused cache entries
14. Provides loading states for async operations

## Technical Notes

- **Integration Approach:** Composition of temporal instance with computed caching
- **Existing Pattern Reference:** Similar to usePeriod but with multiple levels
- **Key Constraints:** Must handle temporal instance lifecycle properly

## Definition of Done

- [ ] Composable created in `/vitepress/.vitepress/composables/useCalendarData.ts`
- [ ] TypeScript interfaces for data structures
- [ ] Temporal instance initialization
- [ ] Year period computation
- [ ] Months computation with caching
- [ ] Days computation with caching
- [ ] Selection state management
- [ ] Cache invalidation logic
- [ ] Loading state indicators
- [ ] Unit tests with mocked temporal
- [ ] JSDoc documentation
- [ ] Integration test with real temporal

## Risk and Compatibility Check

**Minimal Risk Assessment:**
- **Primary Risk:** Memory usage from caching
- **Mitigation:** Implement cache size limits and cleanup
- **Rollback:** N/A - new code only

**Compatibility Verification:**
- [ ] No breaking changes (new code)
- [ ] No database changes
- [ ] No UI components
- [ ] Memory usage within bounds

## Dev Notes

### File Structure
```
/vitepress/.vitepress/composables/useCalendarData.ts
/vitepress/.vitepress/composables/__tests__/useCalendarData.test.ts
```

### Interface Design

```typescript
interface CalendarDataState {
  temporal: Temporal | null
  currentYear: Period | null
  selectedMonth: Period | null
  selectedDay: Period | null
  cache: Map<string, Period[]>
}

interface UseCalendarDataOptions {
  initialDate?: Date
  cacheSize?: number
  adapter?: Adapter
}

interface UseCalendarDataReturn {
  // State
  temporal: Readonly<Ref<Temporal | null>>
  currentYear: ComputedRef<Period | null>
  months: ComputedRef<Period[]>
  days: ComputedRef<Period[]>
  selectedMonth: Readonly<Ref<Period | null>>
  selectedDay: Readonly<Ref<Period | null>>
  isLoading: Ref<boolean>
  
  // Methods
  initialize(options?: UseCalendarDataOptions): void
  selectMonth(month: Period): void
  selectDay(day: Period): void
  clearSelection(): void
  refreshData(): void
  
  // Utilities
  getCacheKey(period: Period, unit: Unit): string
  clearCache(): void
}
```

### Implementation Approach

```typescript
import { createTemporal, divide, period } from '@usetemporal/core'
import { createNativeAdapter } from '@usetemporal/adapters/native'

export function useCalendarData(
  options: UseCalendarDataOptions = {}
): UseCalendarDataReturn {
  const state = reactive<CalendarDataState>({
    temporal: null,
    currentYear: null,
    selectedMonth: null,
    selectedDay: null,
    cache: new Map()
  })
  
  const isLoading = ref(false)
  const maxCacheSize = options.cacheSize ?? 50
  
  // Initialize temporal
  function initialize(opts?: UseCalendarDataOptions) {
    const adapter = opts?.adapter ?? options.adapter ?? createNativeAdapter()
    const date = opts?.initialDate ?? options.initialDate ?? new Date()
    
    state.temporal = createTemporal({ adapter, date })
    state.currentYear = period(state.temporal, date, 'year')
  }
  
  // Computed with caching
  const months = computed(() => {
    if (!state.temporal || !state.currentYear) return []
    
    const cacheKey = getCacheKey(state.currentYear, 'month')
    if (state.cache.has(cacheKey)) {
      return state.cache.get(cacheKey)!
    }
    
    isLoading.value = true
    const result = divide(state.temporal, state.currentYear, 'month')
    
    // Cache management
    if (state.cache.size >= maxCacheSize) {
      // Remove oldest entry
      const firstKey = state.cache.keys().next().value
      state.cache.delete(firstKey)
    }
    state.cache.set(cacheKey, result)
    
    isLoading.value = false
    return result
  })
  
  const days = computed(() => {
    if (!state.temporal || !state.selectedMonth) return []
    
    const cacheKey = getCacheKey(state.selectedMonth, 'day')
    if (state.cache.has(cacheKey)) {
      return state.cache.get(cacheKey)!
    }
    
    isLoading.value = true
    const result = divide(state.temporal, state.selectedMonth, 'day')
    state.cache.set(cacheKey, result)
    isLoading.value = false
    
    return result
  })
  
  // Selection methods
  function selectMonth(month: Period) {
    state.selectedMonth = month
    // Could emit event or trigger navigation here
  }
  
  function selectDay(day: Period) {
    state.selectedDay = day
  }
  
  function clearSelection() {
    state.selectedMonth = null
    state.selectedDay = null
  }
  
  function getCacheKey(period: Period, unit: Unit): string {
    return `${period.start.toISOString()}-${period.end.toISOString()}-${unit}`
  }
  
  function clearCache() {
    state.cache.clear()
  }
  
  function refreshData() {
    clearCache()
    if (state.temporal) {
      state.currentYear = period(
        state.temporal, 
        state.temporal.now.value.date, 
        'year'
      )
    }
  }
  
  // Auto-initialize if options provided
  if (options.adapter || options.initialDate) {
    initialize()
  }
  
  return {
    temporal: readonly(toRef(state, 'temporal')),
    currentYear: computed(() => state.currentYear),
    months,
    days,
    selectedMonth: readonly(toRef(state, 'selectedMonth')),
    selectedDay: readonly(toRef(state, 'selectedDay')),
    isLoading: readonly(isLoading),
    initialize,
    selectMonth,
    selectDay,
    clearSelection,
    refreshData,
    getCacheKey,
    clearCache
  }
}
```

### Cache Strategy

1. **Key Format**: `{start}-{end}-{unit}` ensures uniqueness
2. **Size Limit**: Default 50 entries (configurable)
3. **Eviction**: FIFO when limit reached
4. **Clear Triggers**: 
   - Manual refresh
   - Year change
   - Memory pressure

### Testing Approach

```typescript
// Test with mock temporal
const mockTemporal = {
  adapter: mockAdapter,
  now: ref({ date: new Date('2024-03-15') })
}

// Test caching
const { months, clearCache } = useCalendarData()
const firstCall = months.value
clearCache()
const secondCall = months.value
expect(firstCall).toBe(secondCall) // Same reference = cached
```

### Performance Considerations

1. **Lazy Loading**: Only compute when accessed
2. **Memoization**: Cache computed results
3. **Cleanup**: Clear old cache entries
4. **Batch Updates**: Group state changes

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-07-27 | 1.0 | Initial story creation | Sarah (PO) |

## Dev Agent Record
(To be populated by dev agent)

## QA Results
(To be populated by QA agent)